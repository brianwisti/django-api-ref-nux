{
    "docstring": "\"\"\"\n    A Producer that is sensitive to boundaries.\n\n    Will happily yield bytes until a boundary is found. Will yield the bytes\n    before the boundary, throw away the boundary bytes themselves, and push the\n    post-boundary bytes back on the stream.\n\n    The future calls to next() after locating the boundary will raise a\n    StopIteration exception.\n    \"\"\"",
    "name": "BoundaryIter",
    "namespace": "django.http.multipartparser.BoundaryIter",
    "module_name": "django.http.multipartparser",
    "package_name": "",
    "methods": [
        {
            "docstring": "",
            "name": "__init__",
            "namespace": "django.http.multipartparser.BoundaryIter.__init__",
            "class_name": "",
            "module_name": "",
            "package_name": ""
        },
        {
            "docstring": "",
            "name": "__iter__",
            "namespace": "django.http.multipartparser.BoundaryIter.__iter__",
            "class_name": "",
            "module_name": "",
            "package_name": ""
        },
        {
            "docstring": "",
            "name": "__next__",
            "namespace": "django.http.multipartparser.BoundaryIter.__next__",
            "class_name": "",
            "module_name": "",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n        Find a multipart boundary in data.\n\n        Should no boundary exist in the data, return None. Otherwise, return\n        a tuple containing the indices of the following:\n         * the end of current encapsulation\n         * the start of the next encapsulation\n        \"\"\"",
            "name": "_find_boundary",
            "namespace": "django.http.multipartparser.BoundaryIter._find_boundary",
            "class_name": "",
            "module_name": "",
            "package_name": ""
        }
    ]
}