{
    "namespace": "django.utils.encoding",
    "docstring": "",
    "classes": [
        {
            "docstring": "",
            "name": "DjangoUnicodeDecodeError",
            "namespace": "django.utils.encoding.DjangoUnicodeDecodeError",
            "methods": [
                {
                    "docstring": "",
                    "name": "__init__",
                    "namespace": "django.utils.encoding.DjangoUnicodeDecodeError.__init__",
                    "class_name": "django.utils.encoding.DjangoUnicodeDecodeError",
                    "module_name": "",
                    "package_name": ""
                },
                {
                    "docstring": "",
                    "name": "__str__",
                    "namespace": "django.utils.encoding.DjangoUnicodeDecodeError.__str__",
                    "class_name": "django.utils.encoding.DjangoUnicodeDecodeError",
                    "module_name": "",
                    "package_name": ""
                }
            ]
        }
    ],
    "functions": [
        {
            "docstring": "\"\"\"\n    Return a string representing 's'. Treat bytestrings using the 'encoding'\n    codec.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"",
            "name": "smart_str",
            "namespace": "django.utils.encoding.smart_str",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"Determine if the object instance is of a protected type.\n\n    Objects of protected types are preserved as-is when passed to\n    force_str(strings_only=True).\n    \"\"\"",
            "name": "is_protected_type",
            "namespace": "django.utils.encoding.is_protected_type",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Similar to smart_str(), except that lazy instances are resolved to\n    strings, rather than kept as lazy objects.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"",
            "name": "force_str",
            "namespace": "django.utils.encoding.force_str",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"",
            "name": "smart_bytes",
            "namespace": "django.utils.encoding.smart_bytes",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Similar to smart_bytes, except that lazy instances are resolved to\n    strings, rather than kept as lazy objects.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"",
            "name": "force_bytes",
            "namespace": "django.utils.encoding.force_bytes",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Convert an Internationalized Resource Identifier (IRI) portion to a URI\n    portion that is suitable for inclusion in a URL.\n\n    This is the algorithm from section 3.1 of RFC 3987, slightly simplified\n    since the input is assumed to be a string rather than an arbitrary byte\n    stream.\n\n    Take an IRI (string or UTF-8 bytes, e.g. '/I \u2665 Django/' or\n    b'/I \\xe2\\x99\\xa5 Django/') and return a string containing the encoded\n    result with ASCII chars only (e.g. '/I%20%E2%99%A5%20Django/').\n    \"\"\"",
            "name": "iri_to_uri",
            "namespace": "django.utils.encoding.iri_to_uri",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Convert a Uniform Resource Identifier(URI) into an Internationalized\n    Resource Identifier(IRI).\n\n    This is the algorithm from section 3.2 of RFC 3987, excluding step 4.\n\n    Take an URI in ASCII bytes (e.g. '/I%20%E2%99%A5%20Django/') and return\n    a string containing the encoded result (e.g. '/I%20\u2665%20Django/').\n    \"\"\"",
            "name": "uri_to_iri",
            "namespace": "django.utils.encoding.uri_to_iri",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    Escape the unsafe characters from the path portion of a Uniform Resource\n    Identifier (URI).\n    \"\"\"",
            "name": "escape_uri_path",
            "namespace": "django.utils.encoding.escape_uri_path",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"Return the Punycode of the given domain if it's non-ASCII.\"\"\"",
            "name": "punycode",
            "namespace": "django.utils.encoding.punycode",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    As per section 3.2 of RFC 3987, step three of converting a URI into an IRI,\n    repercent-encode any octet produced that is not part of a strictly legal\n    UTF-8 octet sequence.\n    \"\"\"",
            "name": "repercent_broken_unicode",
            "namespace": "django.utils.encoding.repercent_broken_unicode",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"Convert a file system path to a URI portion that is suitable for\n    inclusion in a URL.\n\n    Encode certain chars that would normally be recognized as special chars\n    for URIs. Do not encode the ' character, as it is a valid character\n    within URIs. See the encodeURIComponent() JavaScript function for details.\n    \"\"\"",
            "name": "filepath_to_uri",
            "namespace": "django.utils.encoding.filepath_to_uri",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        },
        {
            "docstring": "\"\"\"\n    The encoding of the default system locale. Fallback to 'ascii' if the\n    #encoding is unsupported by Python or could not be determined. See tickets\n    #10335 and #5846.\n    \"\"\"",
            "name": "get_system_encoding",
            "namespace": "django.utils.encoding.get_system_encoding",
            "class_name": "",
            "module_name": "django.utils.encoding",
            "package_name": ""
        }
    ],
    "package_name": "django.utils"
}