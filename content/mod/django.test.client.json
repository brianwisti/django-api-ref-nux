{
    "namespace": "django.test.client",
    "docstring": "",
    "classes": [
        {
            "docstring": "\"\"\"The test client has been asked to follow a redirect loop.\"\"\"",
            "name": "RedirectCycleError",
            "namespace": "django.test.client.RedirectCycleError"
        },
        {
            "docstring": "\"\"\"\n    A wrapper around BytesIO that restricts what can be read since data from\n    the network can't be sought and cannot be read outside of its content\n    length. This makes sure that views can't do anything under the test client\n    that wouldn't work in real life.\n    \"\"\"",
            "name": "FakePayload",
            "namespace": "django.test.client.FakePayload"
        },
        {
            "docstring": "\"\"\"\n    An HTTP Handler that can be used for testing purposes. Use the WSGI\n    interface to compose requests, but return the raw HttpResponse object with\n    the originating WSGIRequest attached to its ``wsgi_request`` attribute.\n    \"\"\"",
            "name": "ClientHandler",
            "namespace": "django.test.client.ClientHandler"
        },
        {
            "docstring": "\"\"\"An async version of ClientHandler.\"\"\"",
            "name": "AsyncClientHandler",
            "namespace": "django.test.client.AsyncClientHandler"
        },
        {
            "docstring": "\"\"\"\n    Class that lets you create mock Request objects for use in testing.\n\n    Usage:\n\n    rf = RequestFactory()\n    get_request = rf.get('/hello/')\n    post_request = rf.post('/submit/', {'foo': 'bar'})\n\n    Once you have a request object you can pass it to any view function,\n    just as if that view had been hooked up using a URLconf.\n    \"\"\"",
            "name": "RequestFactory",
            "namespace": "django.test.client.RequestFactory"
        },
        {
            "docstring": "\"\"\"\n    Class that lets you create mock ASGI-like Request objects for use in\n    testing. Usage:\n\n    rf = AsyncRequestFactory()\n    get_request = await rf.get('/hello/')\n    post_request = await rf.post('/submit/', {'foo': 'bar'})\n\n    Once you have a request object you can pass it to any view function,\n    including synchronous ones. The reason we have a separate class here is:\n    a) this makes ASGIRequest subclasses, and\n    b) AsyncTestClient can subclass it.\n    \"\"\"",
            "name": "AsyncRequestFactory",
            "namespace": "django.test.client.AsyncRequestFactory"
        },
        {
            "docstring": "\"\"\"\n    Mixin with common methods between Client and AsyncClient.\n    \"\"\"",
            "name": "ClientMixin",
            "namespace": "django.test.client.ClientMixin"
        },
        {
            "docstring": "\"\"\"\n    A class that can act as a client for testing purposes.\n\n    It allows the user to compose GET and POST requests, and\n    obtain the response that the server gave to those requests.\n    The server Response objects are annotated with the details\n    of the contexts and templates that were rendered during the\n    process of serving the request.\n\n    Client objects are stateful - they will retain cookie (and\n    thus session) details for the lifetime of the Client instance.\n\n    This is not intended as a replacement for Twill/Selenium or\n    the like - it is here to allow testing against the\n    contexts and templates produced by a view, rather than the\n    HTML rendered to the end-user.\n    \"\"\"",
            "name": "Client",
            "namespace": "django.test.client.Client"
        },
        {
            "docstring": "\"\"\"\n    An async version of Client that creates ASGIRequests and calls through an\n    async request path.\n\n    Does not currently support \"follow\" on its methods.\n    \"\"\"",
            "name": "AsyncClient",
            "namespace": "django.test.client.AsyncClient"
        }
    ]
}